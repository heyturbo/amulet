<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>水符/火符高级收益计算器 - 优化版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        :root {
            --primary-color: #3b82f6;
            --secondary-color: #ef4444;
            --tertiary-color: #8b5cf6;
            --border-color: #e5e7eb;
            --bg-light: #f9fafb;
            --bg-dark: #f3f4f6;
            --text-dark: #1f2937;
            --text-medium: #4b5563;
            --text-light: #6b7280;
            --shadow: rgba(0, 0, 0, 0.1) 0px 1px 3px 0px, rgba(0, 0, 0, 0.06) 0px 1px 2px 0px;
            --fire-light: #fee2e2;
            --fire-dark: #ef4444;
            --water-light: #dbeafe;
            --water-dark: #3b82f6;
            --crit-light: #fef9c3;
            --crit-dark: #ca8a04;
            --success-light: #d1fae5;
            --success-dark: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        
        body {
            background-color: #f5f5f5;
            color: var(--text-dark);
            line-height: 1.5;
            padding: 10px;
            max-width: 100%;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
        }
        
        h1, h2, h3, h4 {
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        h1 {
            font-size: 1.5rem;
            text-align: center;
            margin: 10px 0;
            color: var(--text-dark);
        }
        
        h2 {
            font-size: 1.25rem;
            margin-top: 15px;
        }
        
        h3 {
            font-size: 1.125rem;
            margin-top: 15px;
        }
        
        .card {
            background: white;
            border-radius: 8px;
            box-shadow: var(--shadow);
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .grid {
            display: grid;
            gap: 15px;
        }
        
        .grid-2 {
            grid-template-columns: 1fr;
        }
        
        .grid-3 {
            grid-template-columns: 1fr;
        }
        
        .grid-4 {
            grid-template-columns: 1fr 1fr;
        }
        
        @media (min-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr 1fr;
            }
            
            .grid-3 {
                grid-template-columns: 1fr 1fr 1fr;
            }
            
            .grid-4 {
                grid-template-columns: 1fr 1fr 1fr 1fr;
            }
        }
        
        .form-group {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-medium);
        }
        
        input, select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
            font-size: 14px;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }
        
        .result-box {
            background-color: var(--bg-light);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .result-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-medium);
        }
        
        .result-value {
            font-size: 1.25rem;
            font-weight: 500;
            margin-top: 3px;
        }
        
        .result-hint {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-top: 3px;
        }
        
        .chart-container {
            position: relative;
            height: 250px;
            margin: 15px 0;
        }
        
        .fire-color {
            color: var(--fire-dark);
            font-weight: 500;
        }
        
        .water-color {
            color: var(--water-dark);
            font-weight: 500;
        }
        
        .mix-color {
            color: var(--tertiary-color);
            font-weight: 500;
        }
        
        .crit-color {
            color: var(--crit-dark);
            font-weight: 500;
        }
        
        .success-color {
            color: var(--success-dark);
            font-weight: 500;
        }
        
        .conclusion-list {
            padding-left: 20px;
        }
        
        .conclusion-list li {
            margin-bottom: 5px;
        }
        
        .conclusion-list strong {
            font-weight: 500;
        }
        
        .tab-container {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
            font-size: 0.875rem;
        }
        
        .tab.active {
            border-bottom-color: var(--primary-color);
            color: var(--primary-color);
            font-weight: 500;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* 模式切换按钮样式 */
        .mode-switcher {
            display: flex;
            margin-bottom: 15px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        
        .mode-btn {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            background-color: var(--bg-light);
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .mode-btn.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .mode-btn:first-child {
            border-right: 1px solid var(--border-color);
        }
        
        /* 伤害波动提示样式 */
        .damage-range {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-top: 5px;
            font-style: italic;
        }
        
        /* 符价值滑块样式 */
        .talisman-value-container {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            background-color: var(--bg-light);
        }
        
        .talisman-slider-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .talisman-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, var(--water-dark), var(--fire-dark));
            outline: none;
            border-radius: 4px;
        }
        
        .talisman-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 2px solid var(--tertiary-color);
            cursor: pointer;
        }
        
        .talisman-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 2px solid var(--tertiary-color);
            cursor: pointer;
        }
        
        .talisman-values {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
        }
        
        .water-value, .fire-value {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .water-value {
            background-color: var(--water-light);
            color: var(--water-dark);
        }
        
        .fire-value {
            background-color: var(--fire-light);
            color: var(--fire-dark);
        }
        
        .talisman-effect {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
        }
        
        .water-effect, .fire-effect {
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .water-effect {
            color: var(--water-dark);
        }
        
        .fire-effect {
            color: var(--fire-dark);
        }
        
        /* 先后手切换按钮 */
        .turn-switcher {
            display: flex;
            margin-bottom: 15px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        
        .turn-btn {
            flex: 1;
            padding: 8px;
            text-align: center;
            cursor: pointer;
            background-color: var(--bg-light);
            transition: all 0.2s ease;
            font-weight: 500;
            font-size: 0.875rem;
        }
        
        .turn-btn.active {
            background-color: var(--tertiary-color);
            color: white;
        }
        
        .turn-btn:first-child {
            border-right: 1px solid var(--border-color);
        }
        
        /* 最优组合结果样式 */
        .best-combo {
            border: 2px solid var(--tertiary-color);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            background-color: #f5f0ff;
        }
        
        .best-combo-title {
            font-weight: 600;
            color: var(--tertiary-color);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .best-combo-title span {
            font-size: 0.875rem;
            padding: 3px 8px;
            background-color: var(--tertiary-color);
            color: white;
            border-radius: 4px;
        }
        
        .combo-distribution {
            display: flex;
            margin: 10px 0;
        }
        
        .combo-water, .combo-fire {
            padding: 8px 12px;
            border-radius: 4px;
            text-align: center;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .combo-water {
            background-color: var(--water-light);
            color: var(--water-dark);
            margin-right: 10px;
        }
        
        .combo-fire {
            background-color: var(--fire-light);
            color: var(--fire-dark);
        }
        
        .combo-effects {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            margin-top: 10px;
        }
        
        .stats-list {
            margin-top: 10px;
            font-size: 0.875rem;
        }
        
        .stats-list div {
            margin-bottom: 3px;
            display: flex;
            justify-content: space-between;
        }
        
        .stats-list span:first-child {
            color: var(--text-medium);
        }
        
        .stats-list span:last-child {
            font-weight: 500;
        }
        
        /* 暴击参数区域样式 */
        .crit-box {
            background-color: var(--crit-light);
            border: 1px solid var(--crit-dark);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .crit-box h3 {
            color: var(--crit-dark);
            margin-top: 0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .crit-rate-display {
            display: inline-block;
            font-size: 0.875rem;
            padding: 3px 8px;
            background-color: var(--crit-dark);
            color: white;
            border-radius: 4px;
        }
        
        .crit-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }
        
        @media (max-width: 768px) {
            .crit-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            .grid-4 {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.25rem;
            }
            
            .card {
                padding: 12px;
            }
            
            .chart-container {
                height: 200px;
            }
        }
        
        /* 分析说明样式 */
        .analysis-note {
            margin-top: 10px;
            padding: 10px;
            border-radius: 6px;
            background-color: #f0f9ff;
            border: 1px solid #bae6fd;
            font-size: 0.875rem;
        }
        
        /* 预期回合计算区域 */
        .rounds-calculation {
            background-color: var(--success-light);
            border: 1px solid var(--success-dark);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .rounds-calculation h3 {
            color: var(--success-dark);
            margin-top: 0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .expected-rounds-display {
            display: inline-block;
            font-size: 0.875rem;
            padding: 3px 8px;
            background-color: var(--success-dark);
            color: white;
            border-radius: 4px;
        }
        
        .updated-info {
            position: relative;
            padding-left: 20px;
            margin-top: 10px;
            color: var(--success-dark);
            font-size: 0.875rem;
            font-style: italic;
        }
        
        .updated-info::before {
            content: "✓";
            position: absolute;
            left: 0;
            top: 0;
            font-weight: bold;
        }
        
        .version-badge {
            margin-left: 10px;
            font-size: 0.75rem;
            padding: 2px 6px;
            background-color: var(--tertiary-color);
            color: white;
            border-radius: 4px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>水符/火符高级收益计算器 <span class="version-badge">优化版</span></h1>
        
        <!-- 模式切换 -->
        <div class="mode-switcher">
            <div class="mode-btn active" data-mode="monster">野怪模式</div>
            <div class="mode-btn" data-mode="pk">PK模式</div>
        </div>
        
        <!-- 符价值分配 -->
        <div class="card">
            <h3>符价值分配</h3>
            <div class="talisman-value-container">
                <div class="talisman-values">
                    <div class="water-value">水符: <span id="waterValue">10</span></div>
                    <div class="fire-value">火符: <span id="fireValue">15</span></div>
                </div>
                <div class="talisman-slider-container">
                    <input type="range" min="0" max="25" step="5" value="10" class="talisman-slider" id="talismanSlider">
                </div>
                <div class="talisman-effect">
                    <div class="water-effect">再次释放概率: <span id="waterEffect">4%</span></div>
                    <div class="fire-effect">伤害提升: <span id="fireEffect">7%</span></div>
                </div>
                <div class="damage-range" style="text-align: center; margin-top: 15px;">
                    注意: 符的效果按照"价值/5向下取整"决定，一种符达到25点时，另一种符无效
                </div>
            </div>
        </div>
        
        <!-- 暴击参数 -->
        <div class="crit-box">
            <h3>暴击参数 <span class="crit-rate-display" id="critRateDisplay">暴击率: 50.0%</span></h3>
            <div class="crit-grid">
                <div class="form-group">
                    <label for="critValue">暴击值:</label>
                    <input type="number" id="critValue" min="0" value="500">
                </div>
                
                <div class="form-group">
                    <label for="critResistance">暴击抵抗值:</label>
                    <input type="number" id="critResistance" min="0" value="0">
                </div>
                
                <div class="form-group">
                    <label for="playerLevel">玩家等级:</label>
                    <input type="number" id="playerLevel" min="1" value="100">
                </div>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="physicalCrit">
                <label for="physicalCrit">物理暴击 (暴击率上限80%)</label>
            </div>
            
            <div class="form-group">
                <label for="critDamage">暴击伤害倍率:</label>
                <input type="number" id="critDamage" min="1.5" max="5" step="0.1" value="2.0">
                <div class="damage-range">
                    暴击时伤害乘以此倍率，通常为2.0
                </div>
            </div>
        </div>
        
        <!-- 预期回合计算区域 -->
        <div class="rounds-calculation">
            <h3>预期回合计算 <span class="expected-rounds-display" id="expectedRoundsDisplay">预计回合: 8</span></h3>
            <div class="updated-info">更新: 战斗回合数现在会根据攻击力、暴击率和敌人血量自动计算</div>
            <div class="analysis-note">
                回合数不再是手动输入的参数，而是根据您的攻击力、技能系数、暴击率、敌人血量和减伤等因素综合计算的结果。
                这能更准确地反映战斗中的实际情况，并帮助您做出更合理的符咒搭配决策。
            </div>
        </div>
        
        <!-- 控制面板 -->
        <div class="card">
            <div class="grid grid-2">
                <!-- 基础参数 -->
                <div>
                    <h3>基础参数</h3>
                    <div class="form-group">
                        <label for="attackPower">攻击力:</label>
                        <input type="text" id="attackPower" value="300,000">
                    </div>
                    
                    <div class="form-group">
                        <label for="skillCoefficient">技能系数:</label>
                        <input type="number" id="skillCoefficient" min="0.1" max="10" step="0.1" value="1.0">
                    </div>
                    
                    <div class="form-group">
                        <label for="enemyHP">敌人血量:</label>
                        <input type="text" id="enemyHP" value="15,000,000">
                    </div>
                    
                    <!-- 先后手切换 -->
                    <div class="turn-switcher">
                        <div class="turn-btn active" data-turn="first">先手战斗</div>
                        <div class="turn-btn" data-turn="second">后手战斗</div>
                    </div>
                </div>
                
                <!-- PK特有参数 -->
                <div>
                    <h3>防御参数</h3>
                    <div class="form-group">
                        <label for="defenseValue">防御值:</label>
                        <input type="number" id="defenseValue" min="0" max="100000" step="100" value="5000">
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="copperWall">
                        <label for="copperWall">铜墙技能 (减伤增加50%)</label>
                    </div>
                    
                    <div class="result-box">
                        <div class="result-label">当前减伤系数</div>
                        <div id="damageReduction" class="result-value">15.7%</div>
                        <div class="result-hint">基于防御值和技能计算</div>
                    </div>
                    
                    <div class="damage-range">
                        伤害波动范围: 0.9 ~ 1.1 (固定)
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 计算结果 -->
        <div class="card">
            <h3>当前配置分析</h3>
            <div class="grid grid-4">
                <div class="result-box">
                    <div class="result-label">临界血量</div>
                    <div id="criticalHP" class="result-value">4,500,000</div>
                    <div id="criticalHPMillions" class="result-hint">4.50百万</div>
                </div>
                
                <div class="result-box">
                    <div class="result-label">半血回合</div>
                    <div id="halfHpRound" class="result-value">3 / 8</div>
                    <div class="result-hint">达到敌人半血所需回合数</div>
                </div>
                
                <div class="result-box">
                    <div class="result-label">火符总收益</div>
                    <div id="fireBenefit" class="result-value">180,000</div>
                    <div class="result-hint">敌人半血前伤害加成</div>
                </div>
                
                <div class="result-box">
                    <div class="result-label">水符总收益</div>
                    <div id="waterBenefit" class="result-value">450,000</div>
                    <div class="result-hint">技能再次释放收益</div>
                </div>
                
                <div class="result-box">
                    <div class="result-label">收益比(火/水)</div>
                    <div id="benefitRatio" class="result-value">0.400</div>
                    <div id="ratioHint" class="result-hint">水符收益更高</div>
                </div>
                
                <div class="result-box">
                    <div class="result-label">总体收益</div>
                    <div id="totalBenefit" class="result-value">540,000</div>
                    <div id="totalHint" class="result-hint">混合效果总收益</div>
                </div>
                
                <div class="result-box">
                    <div class="result-label">当前配置</div>
                    <div id="currentConfig" class="result-value mix-color">混合搭配</div>
                    <div id="configHint" class="result-hint">水10 + 火15</div>
                </div>
                
                <div class="result-box">
                    <div class="result-label">有效收益比</div>
                    <div id="effectiveRatio" class="result-value">15.3%</div>
                    <div class="result-hint">相比基础伤害的提升</div>
                </div>
            </div>
            
            <!-- 最优组合结果 -->
            <div class="best-combo">
                <div class="best-combo-title">
                    最优组合推荐 <span id="improvementRatio">+12.5%</span>
                </div>
                <div class="combo-distribution">
                    <div class="combo-water" id="bestWater">水符: 5</div>
                    <div class="combo-fire" id="bestFire">火符: 20</div>
                </div>
                <div class="combo-effects">
                    <div class="water-effect">再次释放概率: <span id="bestWaterEffect">2%</span></div>
                    <div class="fire-effect">伤害提升: <span id="bestFireEffect">12%</span></div>
                </div>
                <div class="stats-list">
                    <div><span>总收益率:</span> <span id="bestTotalBenefitRatio">18.6%</span></div>
                    <div><span>预期伤害提升:</span> <span id="bestDamageIncrease">720,000</span></div>
                    <div><span>预计战斗回合:</span> <span id="bestExpectedRounds">8</span></div>
                    <div><span>半血回合数:</span> <span id="bestHalfHpRound">3/8</span></div>
                    <div><span>含暴击总收益:</span> <span id="bestTotalWithCrit" class="crit-color">27.9%</span></div>
                </div>
                <div class="analysis-note">
                    <p id="bestAnalysisNote">推荐前倾重火符配置，当前战斗环境下火符的前期增伤更具价值。</p>
                </div>
            </div>
        </div>
        
        <!-- 图表分析 -->
        <div class="card">
            <div class="tab-container">
                <div class="tab active" data-tab="distributionChart">符价值分配</div>
                <div class="tab" data-tab="roundsChart">回合分析</div>
                <div class="tab" data-tab="defenseChart">减伤影响</div>
                <div class="tab" data-tab="critChart">暴击影响</div>
            </div>
            
            <div id="distributionChart" class="tab-content active">
                <div class="chart-container">
                    <canvas id="distributionChartCanvas"></canvas>
                </div>
            </div>
            
            <div id="roundsChart" class="tab-content">
                <div class="chart-container">
                    <canvas id="roundsChartCanvas"></canvas>
                </div>
            </div>
            
            <div id="defenseChart" class="tab-content">
                <div class="chart-container">
                    <canvas id="defenseChartCanvas"></canvas>
                </div>
            </div>
            
            <div id="critChart" class="tab-content">
                <div class="chart-container">
                    <canvas id="critChartCanvas"></canvas>
                </div>
            </div>
        </div>
        
        <!-- 结论 -->
        <div class="card">
            <h3>实用结论</h3>
            <div id="monsterConclusion">
                <ul class="conclusion-list">
                    <li><strong>符价值分配:</strong> 根据战斗特点决定水火符的最佳分配，按照"价值/5向下取整"决定效果等级</li>
                    <li><strong>临界点影响:</strong> 攻击力越高、敌人血量越低，水符收益相对更高</li>
                    <li><strong>先手影响:</strong> 先手时火符相对更强，因为能享受更多回合的增伤</li>
                    <li><strong>减伤影响:</strong> 减伤越高，火符相对优势越大</li>
                    <li><strong>暴击考量:</strong> 暴击率提高更有利于短期爆发，进一步增强火符在早期回合的效果</li>
                    <li><strong>混搭策略:</strong> 往往纯火符或纯水符并非最优解，根据具体情况选择合适的混搭方案</li>
                    <li class="updated-info"><strong>回合预测:</strong> 计算器现在会自动估算战斗总回合数，更准确地反映水火符实际价值</li>
                </ul>
            </div>
            
            <div id="pkConclusion" style="display: none;">
                <ul class="conclusion-list">
                    <li><strong>PK减伤影响:</strong> 高防御带来的高减伤会使战斗持续更久，火符整体收益更高</li>
                    <li><strong>铜墙效果:</strong> 铜墙进一步增加了有效血量，使火符的相对优势更明显</li>
                    <li><strong>先后手重要性:</strong> PK中先手优势极大，影响火符的有效回合数</li>
                    <li><strong>暴击重要性:</strong> PK中高暴击率能产生爆发力，配合火符前期增伤效果更佳</li>
                    <li><strong>符价值配比:</strong> 短期PK推荐更偏向火符，长期PK考虑平衡搭配</li>
                    <li><strong>真实波动影响:</strong> 实际战斗中伤害波动和暴击可能导致半血临界点提前或延后到来</li>
                    <li class="updated-info"><strong>回合预测:</strong> PK模式下计算器会考虑防御减伤，更准确地估算战斗回合数</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // 数据模型
        const model = {
            // 基本参数
            attackPower: 300000,
            skillCoefficient: 1.0,
            enemyHP: 15000000,
            defenseValue: 5000,
            copperWall: false,
            
            // 符价值
            waterValue: 10,
            fireValue: 15,
            
            // 暴击参数
            critValue: 500,
            critResistance: 0,
            playerLevel: 100,
            physicalCrit: false,
            critDamage: 2.0, // 暴击伤害倍率，通常为2.0
            
            // 模式设置
            gameMode: "monster", // monster 或 pk
            turnOrder: "first", // first 或 second
            damageRangeMin: 0.9,
            damageRangeMax: 1.1,
            
            // 符效果表格
            waterEffects: [0, 0.02, 0.04, 0.06, 0.10, 0.15],
            fireEffects: [0, 0.02, 0.04, 0.07, 0.12, 0.20],
            
            // 获取当前水符等级(考虑排他性)
            getWaterLevel() {
                // 当火符为25时，水符无效
                if (this.fireValue >= 25) {
                    return 0; // 无效，返回0级
                }
                return Math.min(5, Math.floor(this.waterValue / 5));
            },
            
            // 获取当前火符等级(考虑排他性)
            getFireLevel() {
                // 当水符为25时，火符无效
                if (this.waterValue >= 25) {
                    return 0; // 无效，返回0级
                }
                return Math.min(5, Math.floor(this.fireValue / 5));
            },
            
            // 获取当前水符效果
            getWaterEffect() {
                const level = this.getWaterLevel();
                return this.waterEffects[level];
            },
            
            // 获取当前火符效果
            getFireEffect() {
                const level = this.getFireLevel();
                return this.fireEffects[level];
            },
            
            // 计算暴击率
            calculateCritRate() {
                let critRate = (this.critValue - this.critResistance) / this.playerLevel / 100;
                
                // 限制暴击率上限
                if (this.physicalCrit) {
                    critRate = Math.min(0.8, Math.max(0, critRate)); // 物理暴击上限80%
                } else {
                    critRate = Math.min(1.0, Math.max(0, critRate)); // 其他暴击上限100%
                }
                
                return critRate;
            },
            
            // 计算暴击平均伤害倍率
            calculateAvgCritMultiplier() {
                const critRate = this.calculateCritRate();
                // 平均伤害倍率 = 非暴击概率 * 1 + 暴击概率 * 暴击伤害倍率
                return (1 - critRate) * 1 + critRate * this.critDamage;
            },
            
            // 计算减伤系数
            calculateDamageReduction() {
                // 基础减伤 = (防御值/(25000+防御值))-0.1，下限为0
                let reduction = Math.max(0, (this.defenseValue / (25000 + this.defenseValue)) - 0.1);
                
                // 铜墙效果：减伤*1.5
                if (this.copperWall) {
                    reduction = reduction * 1.5;
                }
                
                return Math.min(0.9, reduction); // 最高限制90%减伤
            },
            
            // 获取实际有效血量（考虑减伤）
            getEffectiveHP() {
                if (this.gameMode === "pk") {
                    const damageReduction = this.calculateDamageReduction();
                    // 减伤影响：实际血量 / (1 - 减伤系数)
                    return this.enemyHP / (1 - damageReduction);
                }
                return this.enemyHP;
            },
            
            // 计算平均伤害（考虑波动和暴击）
            getAverageDamage(baseDamage) {
                // 计算波动后的平均伤害
                const minDamage = baseDamage * this.damageRangeMin;
                const maxDamage = baseDamage * this.damageRangeMax;
                const avgWaveDamage = (minDamage + maxDamage) / 2;
                
                // 考虑暴击的平均伤害
                const critMultiplier = this.calculateAvgCritMultiplier();
                const avgDamage = avgWaveDamage * critMultiplier;
                
                if (this.gameMode === "pk") {
                    const damageReduction = this.calculateDamageReduction();
                    // 应用减伤
                    return avgDamage * (1 - damageReduction);
                }
                return avgDamage;
            },
            
            // 计算预期回合数 - 新增函数
            calculateExpectedRounds() {
                const effectiveAttack = this.attackPower * this.skillCoefficient;
                const fireEffect = this.getFireEffect();
                const waterEffect = this.getWaterEffect();
                
                // 基础平均伤害（考虑波动和暴击）
                let avgDamagePerRound = this.getAverageDamage(effectiveAttack);
                
                // 加入水符效果（额外攻击的期望）
                const avgDamageWithWater = avgDamagePerRound * (1 + waterEffect);
                
                // 敌人的有效生命值
                const effectiveHP = this.getEffectiveHP();
                
                // 如果后手，敌人先攻击
                let startingHP = effectiveHP;
                if (this.turnOrder === "second" && this.gameMode === "pk") {
                    startingHP = effectiveHP * 0.85; // 假设敌人造成15%血量伤害
                }
                
                // 初始估计值 - 不考虑火符
                let estimatedRounds = startingHP / avgDamageWithWater;
                
                // 迭代优化估计值，考虑火符在半血前的额外伤害
                for (let i = 0; i < 5; i++) { // 通常5次迭代足够收敛
                    // 估计半血前的回合数
                    const halfHpRounds = Math.min(Math.ceil(estimatedRounds / 2), estimatedRounds);
                    
                    // 半血前的总伤害（有火符效果）
                    const damageBeforeHalf = halfHpRounds * avgDamageWithWater * (1 + fireEffect);
                    
                    // 半血后的总伤害（无火符效果）
                    const damageAfterHalf = Math.max(0, estimatedRounds - halfHpRounds) * avgDamageWithWater;
                    
                    // 总伤害
                    const totalDamage = damageBeforeHalf + damageAfterHalf;
                    
                    // 更新估计值
                    const prevEstimate = estimatedRounds;
                    estimatedRounds = startingHP / (totalDamage / estimatedRounds);
                    
                    // 检查是否收敛
                    if (Math.abs(estimatedRounds - prevEstimate) < 0.1) {
                        break;
                    }
                }
                
                // 返回向上取整的回合数
                return Math.ceil(estimatedRounds);
            },
            
            // 计算临界血量
            calculateCriticalHP() {
                const effectiveAttack = this.attackPower * this.skillCoefficient;
                const expectedRounds = this.calculateExpectedRounds();
                // 基础临界公式 - 修正为使用预期回合数
                return this.getAverageDamage(effectiveAttack) * expectedRounds * 1.5;
            },
            
            // 计算效益比 - 修正版本
            calculateBenefitRatio() {
                const effectiveAttack = this.attackPower * this.skillCoefficient;
                const fireEffect = this.getFireEffect();
                const waterEffect = this.getWaterEffect();
                const critMultiplier = this.calculateAvgCritMultiplier();
                const expectedRounds = this.calculateExpectedRounds();
                
                // 基础伤害序列（考虑先后手、波动和暴击）
                const baseDamages = [];
                for (let i = 0; i < expectedRounds; i++) {
                    baseDamages.push(this.getAverageDamage(effectiveAttack));
                }
                
                // 计算累积伤害和达到半血的回合
                let cumulativeDamage = 0;
                let halfHpRound = expectedRounds;
                const effectiveHP = this.getEffectiveHP();
                
                // 如果后手，考虑敌人先攻击
                let startingHP = effectiveHP;
                if (this.turnOrder === "second" && this.gameMode === "pk") {
                    // 敌人先攻，可能造成血量降低
                    startingHP = effectiveHP * 0.85; // 假设敌人造成15%血量伤害
                }
                
                // 计算半血回合 - 修正为更精确的概率模型
                for (let i = 0; i < baseDamages.length; i++) {
                    // 在敌人血量>50%时应用火符增益
                    let roundDamage = baseDamages[i];
                    if (cumulativeDamage < startingHP / 2) {
                        // 火符增伤 - 在半血前生效
                        roundDamage *= (1 + fireEffect);
                    } else {
                        // 半血后火符不再增伤
                    }
                    
                    // 考虑水符再次释放概率 - 精确计算期望值
                    roundDamage *= (1 + waterEffect);
                    
                    cumulativeDamage += roundDamage;
                    if (cumulativeDamage >= startingHP / 2 && halfHpRound === expectedRounds) {
                        halfHpRound = i + 1;
                    }
                }
                
                // 计算火符和水符独立收益 - 更精确的算法
                let fireBenefit = 0;
                let waterBenefit = 0;
                let totalDamage = 0;
                
                // 重置累积伤害计算独立收益
                cumulativeDamage = 0;
                
                // 回合数据，用于图表
                const roundsData = [];
                
                for (let i = 0; i < baseDamages.length; i++) {
                    let baseDamageForRound = baseDamages[i];
                    let roundFireBenefit = 0;
                    let roundWaterBenefit = 0;
                    
                    // 计算火符单独收益
                    if (cumulativeDamage < startingHP / 2) {
                        // 火符在半血前的增益
                        roundFireBenefit = baseDamageForRound * fireEffect;
                        fireBenefit += roundFireBenefit;
                    }
                    
                    // 计算水符单独收益 - 无论血量都有效
                    roundWaterBenefit = baseDamageForRound * waterEffect;
                    waterBenefit += roundWaterBenefit;
                    
                    // 基础伤害
                    totalDamage += baseDamageForRound;
                    
                    // 更新累积伤害（只考虑基础伤害）
                    cumulativeDamage += baseDamageForRound;
                    
                    // 存储回合数据
                    roundsData.push({
                        round: i + 1,
                        baseDamage: baseDamageForRound,
                        fireBenefit: roundFireBenefit,
                        waterBenefit: roundWaterBenefit,
                        totalDamage: baseDamageForRound + roundFireBenefit + roundWaterBenefit
                    });
                }
                
                // 总收益
                const totalBenefit = fireBenefit + waterBenefit;
                
                // 收益比率，如果水符收益为0，返回Infinity
                const ratio = waterBenefit > 0 ? fireBenefit / waterBenefit : Infinity;
                
                // 相对于总伤害的收益比
                const effectiveRatio = totalBenefit / totalDamage;
                
                // 暴击对各符咒的影响分析
                const critImpact = (critMultiplier - 1) * 100; // 暴击带来的额外收益百分比
                
                return {
                    fireBenefit,
                    waterBenefit,
                    totalBenefit,
                    ratio,
                    halfHpRound,
                    effectiveRatio,
                    critMultiplier,
                    critImpact,
                    roundsData,
                    expectedRounds, // 新增返回预期回合数
                    bestChoice: ratio > 1 ? "火符" : (ratio < 0.95 ? "水符" : "混合")
                };
            },
            
            // 分析战斗属性，生成推荐说明 - 改进版本
            generateRecommendation(bestCombo) {
                // 基于最优组合的水火比例和半血回合等信息
                const waterValue = bestCombo.waterValue;
                const fireValue = bestCombo.fireValue;
                const halfHpRound = bestCombo.halfHpRound;
                const expectedRounds = bestCombo.expectedRounds;
                const halfHpPercentage = (halfHpRound / expectedRounds) * 100;
                
                // 生成更精确的推荐语句
                if (waterValue === 0) {
                    // 纯火符情况
                    if (halfHpPercentage <= 30) {
                        return "推荐纯火符配置，您的高攻击力使敌人血量迅速降至半血，火符前期增伤效果能够最大化发挥。";
                    } else if (halfHpPercentage <= 60) {
                        return "推荐纯火符配置，在当前攻击力和敌人血量配比下，敌人半血前的增伤效果远超水符的再次释放收益。";
                    } else {
                        return "推荐纯火符配置，当前战斗周期长且敌人血量比例高，火符的持续增伤提供最高收益，预计需要" + expectedRounds + "回合战斗。";
                    }
                } else if (fireValue === 0) {
                    // 纯水符情况
                    if (halfHpPercentage <= 20) {
                        return "推荐纯水符配置，您的高攻击力使敌人血量瞬间降至半血以下，水符的再次释放效果在整个战斗过程中更具持续价值。";
                    } else {
                        return "推荐纯水符配置，当前战斗环境下再次释放技能的持续收益超过了前期火符增伤，特别是在战斗预计持续" + expectedRounds + "回合的情况下。";
                    }
                } else {
                    // 混搭情况
                    if (fireValue > waterValue) {
                        return `推荐前倾重火符配置(${fireValue}火${waterValue}水)，当前战斗环境中火符的前期增伤能在半血前(${halfHpRound}/${expectedRounds}回合)提供最大收益。`;
                    } else if (fireValue < waterValue) {
                        return `推荐前倾重水符配置(${waterValue}水${fireValue}火)，您的输出能力和预期战斗回合(${expectedRounds}回合)下，这种配置在整场战斗中提供最平衡收益。`;
                    } else {
                        return `推荐平衡配置(${waterValue}水${fireValue}火)，此配置能在前期和后期都提供稳定收益，适合当前预期持续${expectedRounds}回合的战斗环境。`;
                    }
                }
            },
            
            // 寻找最优组合 - 修正版本
            findBestCombination() {
                const originalWater = this.waterValue;
                const originalFire = this.fireValue;
                
                // 初始默认为纯火符
                let bestCombo = { waterValue: 0, fireValue: 25, benefit: 0 };
                
                // 尝试所有可能的分配方式 (只考虑5的倍数)
                for (let waterValue = 0; waterValue <= 25; waterValue += 5) {
                    const fireValue = 25 - waterValue;
                    
                    // 设置当前测试的价值分配
                    this.waterValue = waterValue;
                    this.fireValue = fireValue;
                    
                    // 计算这个分配的收益
                    const result = this.calculateBenefitRatio();
                    
                    // 如果总收益更高，更新最优组合
                    if (result.totalBenefit > bestCombo.benefit) {
                        bestCombo = {
                            waterValue,
                            fireValue,
                            benefit: result.totalBenefit,
                            waterEffect: this.getWaterEffect(),
                            fireEffect: this.getFireEffect(),
                            halfHpRound: result.halfHpRound,
                            effectiveRatio: result.effectiveRatio,
                            critMultiplier: result.critMultiplier,
                            expectedRounds: result.expectedRounds // 新增存储预期回合数
                        };
                    }
                }
                
                // 恢复原始值
                this.waterValue = originalWater;
                this.fireValue = originalFire;
                
                // 计算当前组合与最优组合的差异
                const currentResult = this.calculateBenefitRatio();
                const improvement = (bestCombo.benefit / (currentResult.totalBenefit || 1) - 1) * 100;
                
                // 添加分析推荐说明
                const recommendation = this.generateRecommendation(bestCombo);
                
                return {
                    ...bestCombo,
                    improvement: improvement,
                    recommendation: recommendation
                };
            },
            
            // 生成符价值分配数据 - 优化版本
            generateDistributionData() {
                const data = [];
                const originalWater = this.waterValue;
                const originalFire = this.fireValue;
                
                for (let waterValue = 0; waterValue <= 25; waterValue += 5) {
                    const fireValue = 25 - waterValue;
                    
                    // 设置当前测试的价值分配
                    this.waterValue = waterValue;
                    this.fireValue = fireValue;
                    
                    // 计算这个分配的收益
                    const result = this.calculateBenefitRatio();
                    
                    data.push({
                        waterValue,
                        fireValue,
                        totalBenefit: result.totalBenefit,
                        effectiveRatio: result.effectiveRatio * 100,
                        expectedRounds: result.expectedRounds // 新增存储预期回合数
                    });
                }
                
                // 填充中间的连续点以平滑曲线
                let smoothedData = [];
                for (let i = 0; i < data.length - 1; i++) {
                    const current = data[i];
                    const next = data[i + 1];
                    
                    smoothedData.push(current);
                    
                    // 添加4个插值点
                    for (let j = 1; j <= 4; j++) {
                        const fraction = j / 5;
                        const interpolatedWaterValue = current.waterValue + (next.waterValue - current.waterValue) * fraction;
                        const interpolatedFireValue = current.fireValue + (next.fireValue - current.fireValue) * fraction;
                        const interpolatedRatio = current.effectiveRatio + (next.effectiveRatio - current.effectiveRatio) * fraction;
                        
                        smoothedData.push({
                            waterValue: interpolatedWaterValue,
                            fireValue: interpolatedFireValue,
                            effectiveRatio: interpolatedRatio
                        });
                    }
                }
                
                // 添加最后一个点
                smoothedData.push(data[data.length - 1]);
                
                // 恢复原始值
                this.waterValue = originalWater;
                this.fireValue = originalFire;
                
                return smoothedData;
            },
            
            // 生成回合分析数据 - 优化版本，使用预期回合数
            generateRoundsData() {
                // 使用计算的预期回合数
                const result = this.calculateBenefitRatio();
                return result.roundsData;
            },
            
            // 生成基于防御值的收益比数据 - 优化版本
            generateDefenseData() {
                if (this.gameMode !== "pk") return [];
                
                const data = [];
                const originalDefense = this.defenseValue;
                const originalCopperWall = this.copperWall;
                
                // 测试没有铜墙的情况
                this.copperWall = false;
                
                const defenseValues = [0, 1000, 2500, 5000, 7500, 10000, 15000, 20000, 30000, 40000, 50000];
                
                for (const defense of defenseValues) {
                    this.defenseValue = defense;
                    const reduction = this.calculateDamageReduction();
                    const result = this.calculateBenefitRatio();
                    
                    data.push({
                        defense,
                        reduction: reduction * 100,
                        ratio: result.ratio,
                        effectiveRatio: result.effectiveRatio * 100,
                        expectedRounds: result.expectedRounds, // 新增存储预期回合数
                        withCopperWall: false
                    });
                }
                
                // 测试有铜墙的情况
                this.copperWall = true;
                
                for (const defense of defenseValues) {
                    this.defenseValue = defense;
                    const reduction = this.calculateDamageReduction();
                    const result = this.calculateBenefitRatio();
                    
                    data.push({
                        defense,
                        reduction: reduction * 100,
                        ratio: result.ratio,
                        effectiveRatio: result.effectiveRatio * 100,
                        expectedRounds: result.expectedRounds, // 新增存储预期回合数
                        withCopperWall: true
                    });
                }
                
                // 恢复原始值
                this.defenseValue = originalDefense;
                this.copperWall = originalCopperWall;
                
                return data;
            },
            
            // 生成基于暴击率的收益比数据 - 优化版本
            generateCritRateData() {
                const data = [];
                
                // 保存原始暴击参数
                const originalCritValue = this.critValue;
                const originalCritResistance = this.critResistance;
                
                // 测试不同暴击值
                const critValues = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000];
                
                for (const critValue of critValues) {
                    this.critValue = critValue;
                    const critRate = this.calculateCritRate();
                    const critMultiplier = this.calculateAvgCritMultiplier();
                    
                    // 计算理想的水火符分配
                    let bestWaterFire = this.findBestCombination();
                    
                    data.push({
                        critValue,
                        critRate: critRate * 100,
                        bestWater: bestWaterFire.waterValue,
                        bestFire: bestWaterFire.fireValue,
                        effectiveRatio: bestWaterFire.effectiveRatio * 100,
                        expectedRounds: bestWaterFire.expectedRounds // 新增存储预期回合数
                    });
                }
                
                // 恢复原始值
                this.critValue = originalCritValue;
                this.critResistance = originalCritResistance;
                
                return data;
            },
            
            // 切换游戏模式并设置相应默认值
            switchGameMode(mode) {
                this.gameMode = mode;
                
                if (mode === "pk") {
                    // 切换到PK模式的默认值
                    this.enemyHP = 1000000; // 100万
                } else {
                    // 切换回野怪模式的默认值
                    this.enemyHP = 15000000; // 1500万
                }
            },
            
            // 切换先后手
            switchTurnOrder(turn) {
                this.turnOrder = turn;
            }
        };
        
        // UI控制器
        const controller = {
            init() {
                this.bindElements();
                this.bindEvents();
                this.updateUI();
                this.initCharts();
            },
            
            bindElements() {
                // 模式切换按钮
                this.modeBtns = document.querySelectorAll('.mode-btn');
                this.turnBtns = document.querySelectorAll('.turn-btn');
                
                // 符价值元素
                this.talismanSlider = document.getElementById('talismanSlider');
                this.waterValueOutput = document.getElementById('waterValue');
                this.fireValueOutput = document.getElementById('fireValue');
                this.waterEffectOutput = document.getElementById('waterEffect');
                this.fireEffectOutput = document.getElementById('fireEffect');
                
                // 暴击参数元素
                this.critValueInput = document.getElementById('critValue');
                this.critResistanceInput = document.getElementById('critResistance');
                this.playerLevelInput = document.getElementById('playerLevel');
                this.physicalCritCheckbox = document.getElementById('physicalCrit');
                this.critDamageInput = document.getElementById('critDamage');
                this.critRateDisplay = document.getElementById('critRateDisplay');
                
                // 预期回合元素
                this.expectedRoundsDisplay = document.getElementById('expectedRoundsDisplay');
                
                // 输入元素
                this.attackPowerInput = document.getElementById('attackPower');
                this.skillCoefficientInput = document.getElementById('skillCoefficient');
                this.enemyHPInput = document.getElementById('enemyHP');
                this.defenseValueInput = document.getElementById('defenseValue');
                this.copperWallCheckbox = document.getElementById('copperWall');
                this.damageReductionOutput = document.getElementById('damageReduction');
                
                // 结论显示
                this.monsterConclusion = document.getElementById('monsterConclusion');
                this.pkConclusion = document.getElementById('pkConclusion');
                
                // 计算结果元素
                this.criticalHPOutput = document.getElementById('criticalHP');
                this.criticalHPMillionsOutput = document.getElementById('criticalHPMillions');
                this.halfHpRoundOutput = document.getElementById('halfHpRound');
                this.fireBenefitOutput = document.getElementById('fireBenefit');
                this.waterBenefitOutput = document.getElementById('waterBenefit');
                this.benefitRatioOutput = document.getElementById('benefitRatio');
                this.ratioHintOutput = document.getElementById('ratioHint');
                this.totalBenefitOutput = document.getElementById('totalBenefit');
                this.totalHintOutput = document.getElementById('totalHint');
                this.currentConfigOutput = document.getElementById('currentConfig');
                this.configHintOutput = document.getElementById('configHint');
                this.effectiveRatioOutput = document.getElementById('effectiveRatio');
                
                // 最优组合元素
                this.improvementRatioOutput = document.getElementById('improvementRatio');
                this.bestWaterOutput = document.getElementById('bestWater');
                this.bestFireOutput = document.getElementById('bestFire');
                this.bestWaterEffectOutput = document.getElementById('bestWaterEffect');
                this.bestFireEffectOutput = document.getElementById('bestFireEffect');
                this.bestTotalBenefitRatioOutput = document.getElementById('bestTotalBenefitRatio');
                this.bestDamageIncreaseOutput = document.getElementById('bestDamageIncrease');
                this.bestExpectedRoundsOutput = document.getElementById('bestExpectedRounds');
                this.bestHalfHpRoundOutput = document.getElementById('bestHalfHpRound');
                this.bestTotalWithCrit = document.getElementById('bestTotalWithCrit');
                this.bestAnalysisNote = document.getElementById('bestAnalysisNote');
                
                // 图表
                this.distributionChartCanvas = document.getElementById('distributionChartCanvas');
                this.roundsChartCanvas = document.getElementById('roundsChartCanvas');
                this.defenseChartCanvas = document.getElementById('defenseChartCanvas');
                this.critChartCanvas = document.getElementById('critChartCanvas');
                
                // 标签页
                this.tabs = document.querySelectorAll('.tab');
                this.tabContents = document.querySelectorAll('.tab-content');
            },
            
            bindEvents() {
                // 模式切换事件
                this.modeBtns.forEach(btn => {
                    btn.addEventListener('click', this.handleModeChange.bind(this));
                });
                
                // 先后手切换事件
                this.turnBtns.forEach(btn => {
                    btn.addEventListener('click', this.handleTurnChange.bind(this));
                });
                
                // 符价值滑块事件
                this.talismanSlider.addEventListener('input', this.handleTalismanSliderChange.bind(this));
                
                // 暴击参数事件
                this.critValueInput.addEventListener('input', this.handleCritValueChange.bind(this));
                this.critResistanceInput.addEventListener('input', this.handleCritResistanceChange.bind(this));
                this.playerLevelInput.addEventListener('input', this.handlePlayerLevelChange.bind(this));
                this.physicalCritCheckbox.addEventListener('change', this.handlePhysicalCritChange.bind(this));
                this.critDamageInput.addEventListener('input', this.handleCritDamageChange.bind(this));
                
                // 输入事件
                this.attackPowerInput.addEventListener('input', this.handleAttackPowerChange.bind(this));
                this.skillCoefficientInput.addEventListener('input', this.handleSkillCoefficientChange.bind(this));
                this.enemyHPInput.addEventListener('input', this.handleEnemyHPChange.bind(this));
                this.defenseValueInput.addEventListener('input', this.handleDefenseValueChange.bind(this));
                this.copperWallCheckbox.addEventListener('change', this.handleCopperWallChange.bind(this));
                
                // 标签页切换
                this.tabs.forEach(tab => {
                    tab.addEventListener('click', this.handleTabClick.bind(this));
                });
            },
            
            handleModeChange(e) {
                const mode = e.target.getAttribute('data-mode');
                
                // 更新UI状态
                this.modeBtns.forEach(btn => {
                    btn.classList.remove('active');
                });
                e.target.classList.add('active');
                
                // 切换模式
                model.switchGameMode(mode);
                
                // 更新UI
                this.updateModeUI(mode);
                this.updateInputValues();
                this.updateUI();
                this.updateCharts();
            },
            
            handleTurnChange(e) {
                const turn = e.target.getAttribute('data-turn');
                
                // 更新UI状态
                this.turnBtns.forEach(btn => {
                    btn.classList.remove('active');
                });
                e.target.classList.add('active');
                
                // 切换先后手
                model.switchTurnOrder(turn);
                
                // 更新UI
                this.updateUI();
                this.updateCharts();
            },
            
            handleTalismanSliderChange(e) {
                const waterValue = parseInt(e.target.value);
                const fireValue = 25 - waterValue;
                
                model.waterValue = waterValue;
                model.fireValue = fireValue;
                
                this.updateTalismanValues();
                this.updateUI();
                this.updateCharts();
            },
            
            handleCritValueChange(e) {
                model.critValue = parseInt(e.target.value) || 0;
                this.updateCritRate();
                this.updateUI();
                this.updateCharts();
            },
            
            handleCritResistanceChange(e) {
                model.critResistance = parseInt(e.target.value) || 0;
                this.updateCritRate();
                this.updateUI();
                this.updateCharts();
            },
            
            handlePlayerLevelChange(e) {
                model.playerLevel = Math.max(1, parseInt(e.target.value) || 1);
                this.updateCritRate();
                this.updateUI();
                this.updateCharts();
            },
            
            handlePhysicalCritChange(e) {
                model.physicalCrit = e.target.checked;
                this.updateCritRate();
                this.updateUI();
                this.updateCharts();
            },
            
            handleCritDamageChange(e) {
                model.critDamage = parseFloat(e.target.value) || 2.0;
                this.updateUI();
                this.updateCharts();
            },
            
            // 更新暴击率显示
            updateCritRate() {
                const critRate = model.calculateCritRate();
                this.critRateDisplay.textContent = `暴击率: ${(critRate * 100).toFixed(1)}%`;
            },
            
            // 更新符价值显示
            updateTalismanValues() {
                this.waterValueOutput.textContent = model.waterValue;
                this.fireValueOutput.textContent = model.fireValue;
                
                // 考虑排他性
                const waterEffect = model.getWaterEffect();
                const fireEffect = model.getFireEffect();
                
                this.waterEffectOutput.textContent = (waterEffect * 100).toFixed(1) + "%";
                this.fireEffectOutput.textContent = (fireEffect * 100).toFixed(1) + "%";
            },
            
            // 更新模式相关UI
            updateModeUI(mode) {
                if (mode === "pk") {
                    this.monsterConclusion.style.display = "none";
                    this.pkConclusion.style.display = "block";
                } else {
                    this.monsterConclusion.style.display = "block";
                    this.pkConclusion.style.display = "none";
                }
            },
            
            // 更新输入框的值
            updateInputValues() {
                this.attackPowerInput.value = this.formatNumber(model.attackPower);
                this.skillCoefficientInput.value = model.skillCoefficient.toFixed(1);
                this.enemyHPInput.value = this.formatNumber(model.enemyHP);
                this.defenseValueInput.value = model.defenseValue;
                this.copperWallCheckbox.checked = model.copperWall;
                this.talismanSlider.value = model.waterValue;
                
                // 更新暴击相关值
                this.critValueInput.value = model.critValue;
                this.critResistanceInput.value = model.critResistance;
                this.playerLevelInput.value = model.playerLevel;
                this.physicalCritCheckbox.checked = model.physicalCrit;
                this.critDamageInput.value = model.critDamage.toFixed(1);
                this.updateCritRate();
                
                // 更新减伤显示
                const reduction = model.calculateDamageReduction();
                this.damageReductionOutput.textContent = (reduction * 100).toFixed(1) + "%";
                
                // 更新预期回合数
                const expectedRounds = model.calculateExpectedRounds();
                this.expectedRoundsDisplay.textContent = `预计回合: ${expectedRounds}`;
            },
            
            handleAttackPowerChange(e) {
                model.attackPower = this.parseNumber(e.target.value);
                this.updateUI();
                this.updateCharts();
            },
            
            handleSkillCoefficientChange(e) {
                model.skillCoefficient = parseFloat(e.target.value) || 1.0;
                this.updateUI();
                this.updateCharts();
            },
            
            handleEnemyHPChange(e) {
                model.enemyHP = this.parseNumber(e.target.value);
                this.updateUI();
                this.updateCharts();
            },
            
            handleDefenseValueChange(e) {
                model.defenseValue = parseInt(e.target.value) || 0;
                
                // 更新减伤显示
                const reduction = model.calculateDamageReduction();
                this.damageReductionOutput.textContent = (reduction * 100).toFixed(1) + "%";
                
                this.updateUI();
                this.updateCharts();
            },
            
            handleCopperWallChange(e) {
                model.copperWall = e.target.checked;
                
                // 更新减伤显示
                const reduction = model.calculateDamageReduction();
                this.damageReductionOutput.textContent = (reduction * 100).toFixed(1) + "%";
                
                this.updateUI();
                this.updateCharts();
            },
            
            handleTabClick(e) {
                const tabId = e.target.getAttribute('data-tab');
                
                // 更新标签页状态
                this.tabs.forEach(tab => {
                    tab.classList.remove('active');
                });
                e.target.classList.add('active');
                
                // 更新内容区域
                this.tabContents.forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabId).classList.add('active');
            },
            
            updateUI() {
                // 获取计算结果
                const results = model.calculateBenefitRatio();
                const criticalHP = model.calculateCriticalHP();
                const bestCombo = model.findBestCombination();
                const critRate = model.calculateCritRate();
                const critMultiplier = model.calculateAvgCritMultiplier();
                const expectedRounds = results.expectedRounds;
                
                // 更新预期回合数显示
                this.expectedRoundsDisplay.textContent = `预计回合: ${expectedRounds}`;
                
                // 更新结果数据
                this.criticalHPOutput.textContent = this.formatNumber(Math.round(criticalHP));
                this.criticalHPMillionsOutput.textContent = (criticalHP / 1000000).toFixed(2) + "百万";
                this.halfHpRoundOutput.textContent = `${results.halfHpRound} / ${expectedRounds}`;
                this.fireBenefitOutput.textContent = this.formatNumber(Math.round(results.fireBenefit));
                this.waterBenefitOutput.textContent = this.formatNumber(Math.round(results.waterBenefit));
                this.benefitRatioOutput.textContent = isFinite(results.ratio) ? results.ratio.toFixed(3) : "∞";
                
                if (results.waterBenefit === 0) {
                    this.ratioHintOutput.textContent = "水符无效";
                } else if (results.fireBenefit === 0) {
                    this.ratioHintOutput.textContent = "火符无效";
                } else {
                    this.ratioHintOutput.textContent = results.ratio > 1 ? "火符收益更高" : "水符收益更高";
                }
                
                this.totalBenefitOutput.textContent = this.formatNumber(Math.round(results.totalBenefit));
                
                // 配置类型
                let configType;
                if (model.waterValue >= 25) configType = "纯水符";
                else if (model.fireValue >= 25) configType = "纯火符";
                else configType = "混合搭配";
                
                this.currentConfigOutput.textContent = configType;
                this.currentConfigOutput.className = "result-value " + 
                    (configType === "纯火符" ? "fire-color" : 
                     configType === "纯水符" ? "water-color" : "mix-color");
                     
                this.configHintOutput.textContent = `水${model.waterValue} + 火${model.fireValue}`;
                this.effectiveRatioOutput.textContent = (results.effectiveRatio * 100).toFixed(1) + "%";
                
                // 更新最优组合
                this.improvementRatioOutput.textContent = "+" + bestCombo.improvement.toFixed(1) + "%";
                this.bestWaterOutput.textContent = "水符: " + bestCombo.waterValue;
                this.bestFireOutput.textContent = "火符: " + bestCombo.fireValue;
                this.bestWaterEffectOutput.textContent = (bestCombo.waterEffect * 100).toFixed(1) + "%";
                this.bestFireEffectOutput.textContent = (bestCombo.fireEffect * 100).toFixed(1) + "%";
                this.bestTotalBenefitRatioOutput.textContent = (bestCombo.effectiveRatio * 100).toFixed(1) + "%";
                this.bestDamageIncreaseOutput.textContent = this.formatNumber(Math.round(bestCombo.benefit));
                this.bestExpectedRoundsOutput.textContent = bestCombo.expectedRounds;
                this.bestHalfHpRoundOutput.textContent = bestCombo.halfHpRound + "/" + bestCombo.expectedRounds;
                
                // 计算含暴击的总收益
                const withCritBenefit = (bestCombo.effectiveRatio * critMultiplier) * 100;
                this.bestTotalWithCrit.textContent = withCritBenefit.toFixed(1) + "%";
                
                // 更新分析说明
                this.bestAnalysisNote.textContent = bestCombo.recommendation;
            },
            
            // 初始化图表
            initCharts() {
                // 符价值分配图表
                this.distributionChart = new Chart(this.distributionChartCanvas, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: '总收益率(%)',
                            borderColor: '#8b5cf6',
                            backgroundColor: 'rgba(139, 92, 246, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.raw.effectiveRatio.toFixed(1);
                                        return `收益率: ${value}%`;
                                    },
                                    title: function(context) {
                                        const water = Math.round(context[0].raw.waterValue);
                                        const fire = Math.round(context[0].raw.fireValue);
                                        return `水符:${water} 火符:${fire}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '水符价值'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '总收益率(%)'
                                }
                            }
                        }
                    }
                });
                
                // 回合分析图表
                this.roundsChart = new Chart(this.roundsChartCanvas, {
                    type: 'bar',
                    data: {
                        datasets: [
                            {
                                label: '基础伤害',
                                backgroundColor: '#9ca3af',
                                stack: 'Stack 0'
                            },
                            {
                                label: '火符增益',
                                backgroundColor: '#ef4444',
                                stack: 'Stack 0'
                            },
                            {
                                label: '水符增益',
                                backgroundColor: '#3b82f6',
                                stack: 'Stack 0'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.raw.y;
                                        if (context.datasetIndex === 0) {
                                            return `基础伤害: ${value.toLocaleString()}`;
                                        } else if (context.datasetIndex === 1) {
                                            return `火符增益: ${value.toLocaleString()}`;
                                        } else {
                                            return `水符增益: ${value.toLocaleString()}`;
                                        }
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '回合数'
                                },
                                stacked: true
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '伤害值'
                                },
                                stacked: true
                            }
                        }
                    }
                });
                
                // 防御影响图表
                this.defenseChart = new Chart(this.defenseChartCanvas, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: '正常',
                                borderColor: '#8b5cf6',
                                backgroundColor: 'rgba(139, 92, 246, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3
                            },
                            {
                                label: '铜墙',
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                borderDash: [5, 5]
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const ratio = context.raw.effectiveRatio.toFixed(1);
                                        const reduction = context.raw.reduction.toFixed(1);
                                        const rounds = context.raw.expectedRounds;
                                        return [
                                            `收益率: ${ratio}%`,
                                            `减伤: ${reduction}%`,
                                            `预计回合: ${rounds}`
                                        ];
                                    },
                                    title: function(context) {
                                        const defense = context[0].raw.defense;
                                        return `防御值: ${defense.toLocaleString()}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '防御值'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '总收益率(%)'
                                }
                            }
                        }
                    }
                });
                
                // 暴击率影响图表
                this.critChart = new Chart(this.critChartCanvas, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: '最优水符配比',
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1'
                            },
                            {
                                label: '最优火符配比',
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1'
                            },
                            {
                                label: '总收益率',
                                borderColor: '#8b5cf6',
                                backgroundColor: 'rgba(139, 92, 246, 0.1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                borderDash: [5, 5],
                                yAxisID: 'y2'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        if (context.datasetIndex === 0) {
                                            return `最优水符: ${context.raw.y}`;
                                        } else if (context.datasetIndex === 1) {
                                            return `最优火符: ${context.raw.y}`;
                                        } else {
                                            return `总收益率: ${context.raw.y.toFixed(1)}%`;
                                        }
                                    },
                                    title: function(context) {
                                        const critValue = context[0].raw.critValue;
                                        const critRate = context[0].raw.critRate.toFixed(1);
                                        const rounds = context[0].raw.expectedRounds;
                                        return `暴击值: ${critValue} (${critRate}%) | 预计回合: ${rounds}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '暴击值'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: '符价值'
                                },
                                min: 0,
                                max: 25
                            },
                            y2: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: '总收益率(%)'
                                },
                                grid: {
                                    drawOnChartArea: false
                                }
                            }
                        }
                    }
                });
                
                this.updateCharts();
            },
            
            // 更新图表数据
            updateCharts() {
                // 更新符价值分配图表
                const distributionData = model.generateDistributionData();
                this.distributionChart.data.labels = distributionData.map(item => item.waterValue);
                this.distributionChart.data.datasets[0].data = distributionData.map(item => ({
                    x: item.waterValue,
                    y: item.effectiveRatio,
                    waterValue: item.waterValue,
                    fireValue: item.fireValue,
                    effectiveRatio: item.effectiveRatio,
                    expectedRounds: item.expectedRounds
                }));
                
                // 标记当前选择的点
                this.distributionChart.data.datasets[0].pointRadius = distributionData.map(item => 
                    Math.abs(item.waterValue - model.waterValue) < 1 ? 6 : 0
                );
                
                // 标记最优组合的点
                const bestCombo = model.findBestCombination();
                this.distributionChart.data.datasets[0].pointBackgroundColor = distributionData.map(item => 
                    Math.abs(item.waterValue - bestCombo.waterValue) < 1 ? '#ef4444' : '#8b5cf6'
                );
                
                this.distributionChart.update();
                
                // 更新回合分析图表
                const roundsData = model.generateRoundsData();
                this.roundsChart.data.labels = roundsData.map(item => item.round);
                
                this.roundsChart.data.datasets[0].data = roundsData.map(item => ({
                    x: item.round,
                    y: item.baseDamage
                }));
                
                this.roundsChart.data.datasets[1].data = roundsData.map(item => ({
                    x: item.round,
                    y: item.fireBenefit
                }));
                
                this.roundsChart.data.datasets[2].data = roundsData.map(item => ({
                    x: item.round,
                    y: item.waterBenefit
                }));
                
                this.roundsChart.update();
                
                // 更新防御影响图表
                const defenseData = model.generateDefenseData();
                
                if (defenseData.length > 0) {
                    // 将数据分为两组：带铜墙和不带铜墙
                    const normalData = defenseData.filter(item => !item.withCopperWall);
                    const copperWallData = defenseData.filter(item => item.withCopperWall);
                    
                    this.defenseChart.data.datasets[0].data = normalData.map(item => ({
                        x: item.defense,
                        y: item.effectiveRatio,
                        defense: item.defense,
                        reduction: item.reduction,
                        effectiveRatio: item.effectiveRatio,
                        expectedRounds: item.expectedRounds
                    }));
                    
                    this.defenseChart.data.datasets[1].data = copperWallData.map(item => ({
                        x: item.defense,
                        y: item.effectiveRatio,
                        defense: item.defense,
                        reduction: item.reduction,
                        effectiveRatio: item.effectiveRatio,
                        expectedRounds: item.expectedRounds
                    }));
                    
                    this.defenseChart.update();
                }
                
                // 更新暴击影响图表
                const critData = model.generateCritRateData();
                
                if (critData.length > 0) {
                    this.critChart.data.labels = critData.map(item => item.critValue);
                    
                    this.critChart.data.datasets[0].data = critData.map(item => ({
                        x: item.critValue,
                        y: item.bestWater,
                        critValue: item.critValue,
                        critRate: item.critRate,
                        expectedRounds: item.expectedRounds
                    }));
                    
                    this.critChart.data.datasets[1].data = critData.map(item => ({
                        x: item.critValue,
                        y: item.bestFire,
                        critValue: item.critValue,
                        critRate: item.critRate,
                        expectedRounds: item.expectedRounds
                    }));
                    
                    this.critChart.data.datasets[2].data = critData.map(item => ({
                        x: item.critValue,
                        y: item.effectiveRatio,
                        critValue: item.critValue,
                        critRate: item.critRate,
                        expectedRounds: item.expectedRounds
                    }));
                    
                    this.critChart.update();
                }
            },
            
            // 辅助函数: 格式化数字
            formatNumber(value) {
                return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            },
            
            // 辅助函数: 解析数字
            parseNumber(value) {
                return parseInt(value.toString().replace(/,/g, "")) || 0;
            }
        };
        
        // 初始化应用
        document.addEventListener('DOMContentLoaded', () => {
            controller.init();
        });
    </script>
</body>
</html>
