import React, { useState, useEffect } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ReferenceLine, Label, ResponsiveContainer } from 'recharts';

const TalismanCalculator = () => {
  // 默认值设置
  const [attackPower, setAttackPower] = useState(300000);  // 默认30万攻击力
  const [skillCoefficient, setSkillCoefficient] = useState(1.0);  // 默认技能系数1.0
  const [totalRounds, setTotalRounds] = useState(10);  // 默认10回合
  const [enemyHP, setEnemyHP] = useState(15000000);  // 默认1500万血量
  
  // 技能伤害模式预设
  const [selectedPattern, setSelectedPattern] = useState("均衡伤害");
  const [customPattern, setCustomPattern] = useState("");
  
  // 基础技能模式
  const skillPatterns = {
    "均衡伤害": Array(10).fill(1.0),
    "前期高伤": [1.5, 1.5, 1.5, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75],
    "后期高伤": [0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 1.5, 1.5, 1.5],
    "波动伤害": [1.2, 0.8, 1.2, 0.8, 1.2, 0.8, 1.2, 0.8, 1.2, 0.8],
    "极前期伤": [2.0, 2.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
    "自定义": []
  };
  
  // 获取当前技能模式
  const getCurrentPattern = () => {
    if (selectedPattern === "自定义") {
      // 解析自定义模式
      try {
        const parsed = customPattern.split(',').map(num => parseFloat(num.trim()));
        if (parsed.length > 0 && !parsed.some(isNaN)) {
          return parsed;
        }
      } catch (e) {
        return skillPatterns["均衡伤害"];
      }
    }
    return skillPatterns[selectedPattern] || skillPatterns["均衡伤害"];
  };

  // 计算临界血量
  const calculateCriticalHP = () => {
    const effectiveAttack = attackPower * skillCoefficient;
    return effectiveAttack * 1.5 * totalRounds;
  };
  
  // 临界血量与当前敌人血量的比较结果
  const getCriticalComparison = () => {
    const criticalHP = calculateCriticalHP();
    if (Math.abs(enemyHP - criticalHP) / criticalHP < 0.05) {
      return "接近临界值";
    }
    return enemyHP > criticalHP ? "选择火符更优" : "选择水符更优";
  };
  
  // 计算收益比
  const calculateBenefitRatio = () => {
    const effectiveAttack = attackPower * skillCoefficient;
    const pattern = getCurrentPattern().slice(0, totalRounds);
    
    // 如果模式长度不足，填充到足够长度
    while (pattern.length < totalRounds) {
      pattern.push(1.0);
    }
    
    // 计算实际伤害序列
    const damages = pattern.map(p => effectiveAttack * p);
    
    // 计算累积伤害和达到半血的回合
    let cumulativeDamage = 0;
    let halfHpRound = totalRounds;
    
    for (let i = 0; i < damages.length; i++) {
      cumulativeDamage += damages[i];
      if (cumulativeDamage >= enemyHP / 2) {
        halfHpRound = i + 1;
        break;
      }
    }
    
    // 计算火符和水符收益
    const fireBenefit = 0.2 * damages.slice(0, halfHpRound).reduce((a, b) => a + b, 0);
    const waterBenefit = 0.15 * damages.reduce((a, b) => a + b, 0);
    const ratio = fireBenefit / waterBenefit;
    
    return {
      fireBenefit,
      waterBenefit,
      ratio,
      halfHpRound,
      bestChoice: ratio > 1 ? "火符" : "水符"
    };
  };
  
  // 生成基于血量的收益比数据
  const generateHpBasedData = () => {
    const effectiveAttack = attackPower * skillCoefficient;
    const data = [];
    
    // 生成从敌人血量50%到200%的范围
    const minHP = enemyHP * 0.2;
    const maxHP = enemyHP * 2;
    const step = (maxHP - minHP) / 40;
    
    for (let hp = minHP; hp <= maxHP; hp += step) {
      // 使用当前选择的技能模式计算
      const pattern = getCurrentPattern().slice(0, totalRounds);
      while (pattern.length < totalRounds) {
        pattern.push(1.0);
      }
      
      // 计算实际伤害序列
      const damages = pattern.map(p => effectiveAttack * p);
      
      // 计算半血回合
      let cumulativeDamage = 0;
      let halfHpRound = totalRounds;
      
      for (let i = 0; i < damages.length; i++) {
        cumulativeDamage += damages[i];
        if (cumulativeDamage >= hp / 2) {
          halfHpRound = i + 1;
          break;
        }
      }
      
      // 计算火符和水符收益
      const fireBenefit = 0.2 * damages.slice(0, halfHpRound).reduce((a, b) => a + b, 0);
      const waterBenefit = 0.15 * damages.reduce((a, b) => a + b, 0);
      const ratio = fireBenefit / waterBenefit;
      
      data.push({
        hp: hp,
        hpMillions: (hp / 1000000).toFixed(2),
        benefitRatio: ratio,
        bestChoice: ratio > 1 ? "火符" : "水符"
      });
    }
    
    return data;
  };
  
  // 生成基于攻击力的收益比数据
  const generateAttackBasedData = () => {
    const data = [];
    const minAttack = attackPower * 0.2;
    const maxAttack = attackPower * 2;
    const step = (maxAttack - minAttack) / 40;
    
    for (let atk = minAttack; atk <= maxAttack; atk += step) {
      const effectiveAttack = atk * skillCoefficient;
      
      // 使用当前选择的技能模式计算
      const pattern = getCurrentPattern().slice(0, totalRounds);
      while (pattern.length < totalRounds) {
        pattern.push(1.0);
      }
      
      // 计算实际伤害序列
      const damages = pattern.map(p => effectiveAttack * p);
      
      // 计算半血回合
      let cumulativeDamage = 0;
      let halfHpRound = totalRounds;
      
      for (let i = 0; i < damages.length; i++) {
        cumulativeDamage += damages[i];
        if (cumulativeDamage >= enemyHP / 2) {
          halfHpRound = i + 1;
          break;
        }
      }
      
      // 计算火符和水符收益
      const fireBenefit = 0.2 * damages.slice(0, halfHpRound).reduce((a, b) => a + b, 0);
      const waterBenefit = 0.15 * damages.reduce((a, b) => a + b, 0);
      const ratio = fireBenefit / waterBenefit;
      
      data.push({
        attack: atk,
        attackK: (atk / 10000).toFixed(1),
        benefitRatio: ratio,
        bestChoice: ratio > 1 ? "火符" : "水符"
      });
    }
    
    return data;
  };
  
  // 生成临界回合数据
  const generateRoundBasedData = () => {
    const effectiveAttack = attackPower * skillCoefficient;
    const criticalHP = effectiveAttack * 1.5 * totalRounds;
    
    return {
      effectiveAttack,
      criticalHP,
      criticalHPMillions: (criticalHP / 1000000).toFixed(2),
      comparisonResult: getCriticalComparison()
    };
  };
  
  // 计算并获取当前结果
  const results = calculateBenefitRatio();
  const criticalData = generateRoundBasedData();
  const hpData = generateHpBasedData();
  const attackData = generateAttackBasedData();
  
  // 处理自定义模式输入变化
  const handleCustomPatternChange = (e) => {
    setCustomPattern(e.target.value);
    if (selectedPattern !== "自定义") {
      setSelectedPattern("自定义");
    }
  };
  
  // 处理数值输入格式化
  const formatNumber = (value) => {
    return value ? value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",") : "";
  };
  
  const parseNumber = (value) => {
    return value ? parseInt(value.toString().replace(/,/g, "")) : 0;
  };

  return (
    <div className="flex flex-col gap-6 p-4">
      <h2 className="text-2xl font-bold text-center">火符与水符效益交互式计算器</h2>
      
      {/* 控制面板 */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 p-4 border rounded bg-gray-50">
        <div className="flex flex-col gap-4">
          <h3 className="text-lg font-semibold">基础参数</h3>
          
          <div className="flex flex-col gap-2">
            <label className="font-medium">攻击力:</label>
            <input
              type="text"
              value={formatNumber(attackPower)}
              onChange={(e) => setAttackPower(parseNumber(e.target.value))}
              className="p-2 border rounded"
            />
          </div>
          
          <div className="flex flex-col gap-2">
            <label className="font-medium">技能系数:</label>
            <input
              type="number"
              step="0.1"
              min="0.1"
              max="10"
              value={skillCoefficient}
              onChange={(e) => setSkillCoefficient(parseFloat(e.target.value))}
              className="p-2 border rounded"
            />
          </div>
          
          <div className="flex flex-col gap-2">
            <label className="font-medium">战斗回合数:</label>
            <input
              type="number"
              min="1"
              max="30"
              value={totalRounds}
              onChange={(e) => setTotalRounds(parseInt(e.target.value))}
              className="p-2 border rounded"
            />
          </div>
          
          <div className="flex flex-col gap-2">
            <label className="font-medium">敌人血量:</label>
            <input
              type="text"
              value={formatNumber(enemyHP)}
              onChange={(e) => setEnemyHP(parseNumber(e.target.value))}
              className="p-2 border rounded"
            />
          </div>
        </div>
        
        <div className="flex flex-col gap-4">
          <h3 className="text-lg font-semibold">技能伤害模式</h3>
          
          <div className="flex flex-col gap-2">
            <label className="font-medium">预设模式:</label>
            <select
              value={selectedPattern}
              onChange={(e) => setSelectedPattern(e.target.value)}
              className="p-2 border rounded"
            >
              {Object.keys(skillPatterns).map(pattern => (
                <option key={pattern} value={pattern}>{pattern}</option>
              ))}
            </select>
          </div>
          
          <div className="flex flex-col gap-2">
            <label className="font-medium">自定义模式 (用逗号分隔系数):</label>
            <textarea
              value={customPattern}
              onChange={handleCustomPatternChange}
              placeholder="例如: 1.5, 1.2, 0.8, 0.5"
              className="p-2 border rounded h-24"
            />
          </div>
          
          <div className="mt-4 p-3 border rounded bg-white">
            <h4 className="font-medium">当前模式预览:</h4>
            <div className="flex flex-wrap gap-2 mt-2">
              {getCurrentPattern().slice(0, totalRounds).map((value, index) => (
                <span 
                  key={index}
                  className="px-2 py-1 text-sm rounded"
                  style={{
                    backgroundColor: value > 1 ? "#fecaca" : value < 1 ? "#bfdbfe" : "#e5e7eb"
                  }}
                >
                  {value.toFixed(1)}
                </span>
              ))}
            </div>
          </div>
        </div>
      </div>
      
      {/* 结果面板 */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div className="p-4 border rounded bg-white">
          <h3 className="text-lg font-semibold mb-4">计算结果</h3>
          
          <div className="grid grid-cols-2 gap-4">
            <div className="p-3 border rounded bg-gray-50">
              <h4 className="font-medium">临界血量</h4>
              <p className="text-xl mt-1">{formatNumber(criticalData.criticalHP)}</p>
              <p className="text-sm text-gray-500">{criticalData.criticalHPMillions}百万</p>
            </div>
            
            <div className="p-3 border rounded bg-gray-50">
              <h4 className="font-medium">半血回合</h4>
              <p className="text-xl mt-1">{results.halfHpRound} / {totalRounds}</p>
              <p className="text-sm text-gray-500">
                达到敌人半血所需回合数
              </p>
            </div>
            
            <div className="p-3 border rounded bg-gray-50">
              <h4 className="font-medium">火符总收益</h4>
              <p className="text-xl mt-1">{formatNumber(Math.round(results.fireBenefit))}</p>
              <p className="text-sm text-gray-500">
                敌人半血前20%伤害加成
              </p>
            </div>
            
            <div className="p-3 border rounded bg-gray-50">
              <h4 className="font-medium">水符总收益</h4>
              <p className="text-xl mt-1">{formatNumber(Math.round(results.waterBenefit))}</p>
              <p className="text-sm text-gray-500">
                全程15%概率再次释放
              </p>
            </div>
            
            <div className="p-3 border rounded bg-gray-50">
              <h4 className="font-medium">收益比(火/水)</h4>
              <p className="text-xl mt-1">{results.ratio.toFixed(3)}</p>
              <p className="text-sm text-gray-500">
                {results.ratio > 1 ? '火符收益更高' : '水符收益更高'}
              </p>
            </div>
            
            <div className="p-3 border rounded bg-gray-50">
              <h4 className="font-medium">推荐选择</h4>
              <p className="text-xl mt-1 font-semibold" style={{
                color: results.bestChoice === "火符" ? "#dc2626" : "#2563eb"
              }}>
                {results.bestChoice}
              </p>
              <p className="text-sm text-gray-500">
                {criticalData.comparisonResult}
              </p>
            </div>
          </div>
          
          <div className="mt-6 p-4 border rounded bg-gray-50">
            <h4 className="font-medium mb-2">有效伤害分析</h4>
            <p><span className="font-medium">基础攻击力:</span> {formatNumber(attackPower)}</p>
            <p><span className="font-medium">技能系数:</span> {skillCoefficient}</p>
            <p><span className="font-medium">有效攻击力:</span> {formatNumber(Math.round(attackPower * skillCoefficient))}</p>
            <p className="mt-2"><span className="font-medium">敌人血量:</span> {formatNumber(enemyHP)}</p>
            <p><span className="font-medium">敌人半血值:</span> {formatNumber(Math.round(enemyHP / 2))}</p>
          </div>
        </div>
        
        <div className="p-4 border rounded bg-white">
          <h3 className="text-lg font-semibold mb-2">敌人血量与收益比关系</h3>
          <p className="mb-4 text-sm text-gray-600">保持其他参数不变，改变敌人血量会怎样影响收益比</p>
          
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={hpData} margin={{ top: 5, right: 30, left: 20, bottom: 25 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis 
                dataKey="hpMillions" 
                label={{ value: '敌人血量(百万)', position: 'bottom', offset: 0 }} 
              />
              <YAxis 
                label={{ value: '火符/水符收益比', angle: -90, position: 'insideLeft' }} 
              />
              <Tooltip 
                formatter={(value) => [value.toFixed(3), '收益比']}
                labelFormatter={(value) => `血量: ${value}百万`}
              />
              <ReferenceLine y={1} stroke="red" strokeDasharray="3 3">
                <Label value="临界值" position="right" />
              </ReferenceLine>
              <Line 
                type="monotone" 
                dataKey="benefitRatio" 
                name="收益比" 
                stroke="#8884d8" 
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
          
          <h3 className="text-lg font-semibold mb-2 mt-6">攻击力与收益比关系</h3>
          <p className="mb-4 text-sm text-gray-600">保持其他参数不变，改变攻击力会怎样影响收益比</p>
          
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={attackData} margin={{ top: 5, right: 30, left: 20, bottom: 25 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis 
                dataKey="attackK" 
                label={{ value: '攻击力(万)', position: 'bottom', offset: 0 }} 
              />
              <YAxis 
                label={{ value: '火符/水符收益比', angle: -90, position: 'insideLeft' }} 
              />
              <Tooltip 
                formatter={(value) => [value.toFixed(3), '收益比']}
                labelFormatter={(value) => `攻击力: ${value}万`}
              />
              <ReferenceLine y={1} stroke="red" strokeDasharray="3 3">
                <Label value="临界值" position="right" />
              </ReferenceLine>
              <Line 
                type="monotone" 
                dataKey="benefitRatio" 
                name="收益比" 
                stroke="#4ade80" 
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </div>
      
      <div className="p-4 border rounded bg-gray-50">
        <h3 className="text-lg font-semibold mb-2">实用结论</h3>
        <ul className="list-disc pl-5 space-y-1">
          <li><span className="font-medium">临界值公式:</span> 敌人血量 = 攻击力 × 技能系数 × 1.5 × 回合数</li>
          <li><span className="font-medium">当敌人血量 &lt; 临界值时:</span> 水符更优 (15%的持续收益)</li>
          <li><span className="font-medium">当敌人血量 &gt; 临界值时:</span> 火符更优 (敌人长时间保持在半血以上)</li>
          <li><span className="font-medium">技能伤害分布影响:</span> 前期高伤害分布更有利于火符，后期高伤害分布更有利于水符</li>
          <li><span className="font-medium">实战选择:</span> 对抗小怪群通常选择水符，对抗高血量BOSS通常选择火符</li>
        </ul>
      </div>
    </div>
  );
};

export default TalismanCalculator;
